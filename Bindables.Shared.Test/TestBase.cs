using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NUnit.Framework;

namespace Bindables.Test;

public abstract class TestBase
{
	public abstract string AttributeNamespace { get; }
	public abstract string PlatformNamespace { get; }
	public abstract string BaseClassName { get; }
	public abstract string DependencyPropertyName { get; }
	public abstract string DependencyPropertyKeyName { get; }
	public abstract string[] PropertyChangedMethodParameterTypes { get; }

	public TestResult Generate<T>(
		string? sourceCode = null,
		IReadOnlyList<AdditionalText>? additionalTexts = null,
		IReadOnlyList<SyntaxTree>? additionalSyntaxTrees = null)
		where T : IIncrementalGenerator, new()
	{
		List<MetadataReference> references = new();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

		foreach (Assembly assembly in assemblies)
		{
			if (!assembly.IsDynamic)
			{
				references.Add(MetadataReference.CreateFromFile(assembly.Location));
			}
		}

		references.AddRange(GetAdditionalReferences());

		List<SyntaxTree> syntaxTrees = new();

		if (sourceCode != null)
		{
			syntaxTrees.Add(CSharpSyntaxTree.ParseText(sourceCode));
		}

		if (additionalSyntaxTrees != null)
		{
			syntaxTrees.AddRange(additionalSyntaxTrees);
		}

		CSharpCompilation compilation = CSharpCompilation.Create(
			"original",
			syntaxTrees,
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

		GeneratorDriver driver = CSharpGeneratorDriver.Create(new T());

		if (additionalTexts != null)
		{
			driver = driver.AddAdditionalTexts(ImmutableArray.CreateRange(additionalTexts));
		}

		driver.RunGeneratorsAndUpdateCompilation(
			compilation,
			out Compilation outputCompilation,
			out ImmutableArray<Diagnostic> diagnostics);

		List<Diagnostic> compilationErrors = outputCompilation
			.GetDiagnostics()
			.Where(x => x.Severity == DiagnosticSeverity.Error)
			.ToList();

		compilationErrors.AddRange(diagnostics);

		List<SyntaxTree> resultSyntaxTrees = outputCompilation.SyntaxTrees
			.Where(x => x.ToString().Contains("// Generated by Bindables"))
			.ToList();

		return new TestResult(resultSyntaxTrees, compilationErrors);
	}

	protected virtual IEnumerable<MetadataReference> GetAdditionalReferences()
	{
		return Enumerable.Empty<MetadataReference>();
	}

	public void CheckResult(TestResult result)
	{
		PrintSyntaxTrees(result);
		PrintWarningMessages(result);

		List<string> errorMessages = result.Diagnostics
			.Where(x => x.Severity >= DiagnosticSeverity.Error)
			.Select(x => x.ToString())
			.ToList();

		if (errorMessages.Any())
		{
			Assert.Fail(string.Join("\n", errorMessages));
		}
	}

	private void PrintSyntaxTrees(
		TestResult result,
		string? sourceCode = null,
		List<SyntaxTree>? additionalSyntaxTrees = null)
	{
		foreach (SyntaxTree syntaxTree in result.SyntaxTrees)
		{
			if (syntaxTree.ToString() == sourceCode)
			{
				continue;
			}

			if (additionalSyntaxTrees?.Contains(syntaxTree) == true)
			{
				continue;
			}

			Debug.WriteLine(syntaxTree);
		}
	}

	private void PrintWarningMessages(TestResult result)
	{
		List<string> warningMessages = result.Diagnostics
			.Where(x => x.Severity == DiagnosticSeverity.Warning)
			.Select(x => x.ToString())
			.ToList();

		foreach (string message in warningMessages)
		{
			Console.WriteLine(message);
		}
	}
}